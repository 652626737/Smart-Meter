#define BLINKER_WIFI // 设置连接模式为 BLINKER_WIFI
#include <Blinker.h>
#include <PZEM004Tv30.h>
#include <Tasker.h>
#include <EEPROM.h>
#include <WiFi.h>

#include <config.h> // 包含 ESP32 的 WiFi 库
#include "ESP_Mail_Client_Wrapper.h"
#include "EEPROMManager.h"

BlinkerNumber VOLTAGE("Voltage");
BlinkerNumber CURRENT("current");
BlinkerNumber POWER("power");
BlinkerText ENERGY("energy");
BlinkerNumber FREQUENCY("frequency");
BlinkerNumber PF("pf");

ESP_Mail_Client_Wrapper mailWrapper;

bool emailSent = false;
bool Debug = true;
float lastenergy = 0.0;
int Runday = 21;
unsigned long previousMillis = 0;  // 上一次任务执行的时间
const long interval = 10000;       // 任务执行间隔为10秒


#if !defined(PZEM_RX_PIN) && !defined(PZEM_TX_PIN)
#define PZEM_RX_PIN 16
#define PZEM_TX_PIN 17
#endif

#if !defined(PZEM_SERIAL)
#define PZEM_SERIAL Serial2
#endif

PZEM004Tv30 pzem(PZEM_SERIAL, PZEM_RX_PIN, PZEM_TX_PIN);

// 创建一个定时器对象
Tasker tasker;
Tasker eepromTimer; // 创建一个定时器对象

// 写入 EEPROM 的地址偏移量
int eepromAddress = 131073;
EEPROMManager eepromManager(eepromAddress);

SensorData sensorData;
// 读取传感器数据
SensorData readSensorData()
{
	SensorData localSensorData;
	if (Debug)
	{
		// 输入测试传感器数据...
		localSensorData.voltage = random(200, 250) / 10.0;	// 产生 20.0 到 25.0 之间的随机数
		localSensorData.current = random(50, 150) / 10.0;	// 产生 5.0 到 15.0 之间的随机数
		localSensorData.power = random(500, 1000);			// 产生 500 到 1000 之间的随机数
		localSensorData.energy = random(100, 1000) / 100.0; // 产生 1.0 到 10.0 之间的随机数
		localSensorData.frequency = random(50, 60);			// 产生 50 到 60 之间的随机数
		localSensorData.pf = random(80, 100) / 100.0;		// 产生 0.8 到 1.0 之间的随机数
	}
	else
	{
		// 读取传感器数据...
		localSensorData.voltage = pzem.voltage();
		localSensorData.current = pzem.current();
		localSensorData.power = pzem.power();
		localSensorData.energy = pzem.energy();
		localSensorData.frequency = pzem.frequency();
		localSensorData.pf = pzem.pf();
	}

	if (Debug)
	{
		Serial.print("test_Voltage: ");
		Serial.print(localSensorData.voltage);
		Serial.println("V");
		Serial.print("test_Current: ");
		Serial.print(localSensorData.current);
		Serial.println("A");
		Serial.print("test_Power: ");
		Serial.print(localSensorData.power);
		Serial.println("W");
		Serial.print("test_Energy: ");
		Serial.print(localSensorData.energy, 3);
		Serial.println("kWh");
		Serial.print("test_Frequency: ");
		Serial.print(localSensorData.frequency, 1);
		Serial.println("Hz");
		Serial.print("test_PF: ");
		Serial.println(localSensorData.pf);
	}
	return localSensorData;
}

void heartbeat()
{

	if (isnan(sensorData.voltage) || isnan(sensorData.current) || isnan(sensorData.power) || isnan(sensorData.energy) || isnan(sensorData.frequency) || isnan(sensorData.pf)) // 判断是否为NAN
	{
		sensorData.voltage = 0.0;
		sensorData.current = 0.0;
		sensorData.power = 0.0;
		sensorData.energy = 0.0;
		sensorData.frequency = 0.0;
		sensorData.pf = 0.0;
		// 发送实时数据到云平台
		Blinker.sendRtData("energy", sensorData.energy);
		Blinker.sendRtData("Voltage", sensorData.voltage);
		Blinker.sendRtData("current", sensorData.current);
		Blinker.sendRtData("power", sensorData.power);
		Blinker.sendRtData("frequency", sensorData.frequency);
		// Blinker.sendRtData("pf", pzem.pf());
	}
	else
	{
		Blinker.sendRtData("energy", sensorData.energy);
		Blinker.sendRtData("Voltage", sensorData.voltage);
		Blinker.sendRtData("current", sensorData.current);
		Blinker.sendRtData("power", sensorData.power);
		Blinker.sendRtData("frequency", sensorData.frequency);
		// Blinker.sendRtData("pf", pzem.pf());
	}
}

int calculateEEPROMAddressOffset()
{
	int eepromAddress = 0;

	// 计算每个字段的大小
	int sizeOfVoltage = sizeof(float);
	int sizeOfCurrent = sizeof(float);
	int sizeOfPower = sizeof(float);
	int sizeOfEnergy = sizeof(float);
	int sizeOfFrequency = sizeof(float);
	int sizeOfPF = sizeof(float);

	// 更新EEPROM地址偏移量
	eepromAddress += sizeOfVoltage;
	eepromAddress += sizeOfCurrent;
	eepromAddress += sizeOfPower;
	eepromAddress += sizeOfEnergy;
	eepromAddress += sizeOfFrequency;
	eepromAddress += sizeOfPF;

	return eepromAddress;
}

/**
 * @brief 读取传感器数据并存储到EEPROM
 *
 * 从传感器中读取数据，并将其存储到EEPROM中。
 */
void readSensorDataAndStoreToEEPROM()
{

	eepromManager.writeSensorData(readSensorData());
	if (Debug)
	{
		SensorData TempData;
		// 获取EPPROM数据
		TempData = eepromManager.readSensorData();
		// 打印读取到的传感器数据
		Serial.println("-----------------Read sensor data from EEPROM:----------------");
		Serial.print("Voltage: ");  
		Serial.println(TempData.voltage);
		Serial.print("Current: ");
		Serial.println(TempData.current);
		Serial.print("Power: ");
		Serial.println(TempData.power);
		Serial.print("Energy: ");
		Serial.println(TempData.energy);
		Serial.print("Frequency: ");
		Serial.println(TempData.frequency);
		Serial.print("Power Factor: ");
		Serial.println(TempData.pf);
	}
}

void updateTask() {
  unsigned long currentMillis = millis();

  // 检查是否到达执行间隔
  if (currentMillis - previousMillis >= interval) {
    // 保存此次任务执行的时间
    previousMillis = currentMillis;

    // 在这里执行需要定时执行的任务
    Serial.println("Timer task executed.");
	readSensorDataAndStoreToEEPROM();
  }
}


/**
 * @brief 发送电子邮件
 *
 * 发送包含本月电费统计信息的电子邮件。
 *
 * 此函数首先获取当前时间，并确定当前月份。
 * 如果上次的能量值为0.00，则从EEPROM中获取能量值。
 * 根据传感器数据和上次的能量值，计算能量差值，并计算电费。
 * 构造包含本月起始能量、本月终止能量、本月合计能量和本月电费等信息的邮件内容。
 * 调用邮件包装器发送邮件，邮件的附加内容为构造好的字符串，邮件主题为当前月份的电费统计。
 * 最后，更新上次的能量值为传感器数据的能量值，并将其存储到EEPROM中。
 */
void sendEmail()
{
	time_t now = time(nullptr);

	int month = localtime(&now)->tm_mon + 1;

	if (lastenergy == 0.00)
	{
		//  取eeprom数据
		if (EEPROM.get(calculateEEPROMAddressOffset(), lastenergy) == 0.00 || isnan(lastenergy) || lastenergy < 0.000)
		{
			lastenergy = 0.000;
		}
		else
		{
			lastenergy = EEPROM.get(calculateEEPROMAddressOffset(), lastenergy);
		}
	}

	float energyDifference = sensorData.energy - lastenergy;
	float electricityCost = energyDifference * 1.5; // 这里假设电费等于能量差值，你可以根据实际情况修改

	// 发送邮件
	mailWrapper.send_mail(/* subject */ String(month) + "本月电费统计",
						  /* additionalContent */
						  "本月起始:" + String(lastenergy, 3) + "\r\n\r\n" +
							  "本月终止:" + String(sensorData.energy, 3) + "\r\n\r\n" +
							  "本月合计:" + String(energyDifference, 3) + "\r\n\r\n" +
							  "本月电费:" + String(electricityCost, 3) + "\r\n\r\n");

	lastenergy = sensorData.energy;
	EEPROM.put(calculateEEPROMAddressOffset(), lastenergy);
}

void setup()
{
	// Debugging Serial port
	Serial.begin(115200);
	Serial.print("Welcome to ESP32 Smart Meters");

	Blinker.begin(auth, ssid, password);
	Blinker.attachHeartbeat(heartbeat); // 注册心跳包
	tasker.setInterval(readSensorDataAndStoreToEEPROM, 5000, 0);
	tasker.setInterval(updateTask, interval);
	WiFi.begin(ssid, password);
	Serial.print("连接到 Wi-Fi");
	while (WiFi.status() != WL_CONNECTED)
	{
		Serial.print(".");
		delay(300);
	}
	Serial.println();
	Serial.print("Connected with IP: ");
	Serial.println(WiFi.localIP());
	Serial.println();

	// 读取 EEPROM 中的传感器数据（如果有的话）
	SensorData init_SensorData = eepromManager.readSensorData();
	if (Debug)
	{
		// 打印 EEPROM 中读取的传感器数据到串口
		Serial.print("init_Voltage from EEPROM: ");
		Serial.print(init_SensorData.voltage,3);
		Serial.println("V");
		Serial.print("inigt_Current from EEPROM: ");
		Serial.print(init_SensorData.current,3);
		Serial.println("A");
		Serial.print("init_Power from EEPROM: ");
		Serial.print(init_SensorData.power,3);
		Serial.println("W");
		Serial.print("init_Energy from EEPROM: ");
		Serial.print(init_SensorData.energy, 3);
		Serial.println("kWh");
		Serial.print("init_Frequency from EEPROM: ");
		Serial.print(init_SensorData.frequency, 3);
		Serial.println("Hz");
		Serial.print("init_ PF from EEPROM: ");
		Serial.println(init_SensorData.pf),3;
	}
}

void loop()
{
	// time_t now = time(nullptr);

	// int day = localtime(&now)->tm_mday;

	// // 判断当前时间是不是当月20号,如果是的话发送邮件 当天只调用一次

	// if (Debug)
	// {
	// 	sendEmail();
	// 	// 邮件发送成功后，将 emailSent 标志设置为 true
	// 	emailSent = true;
	// }
	// else
	// {
	// 	if (day == Runday && !emailSent)
	// 	{
	// 		sendEmail();
	// 		// 邮件发送成功后，将 emailSent 标志设置为 true
	// 		emailSent = true;
	// 	}
	// 	else
	// 	{
	// 		if (day != Runday)
	// 		{
	// 			emailSent = false;
	// 		}
	// 	}
	// }
	// sensorData = readSensorData();

	Blinker.run();
	// 在 loop() 中调用 timer.run()，用于执行定时器任务
	tasker.loop();
	// Other tasks in loop can continue here
}